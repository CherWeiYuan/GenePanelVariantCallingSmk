# To run: snakemake --use-conda --retries 3 --cores 48 
# To test: snakemake --use-conda --cores 48 
# Dry run: snakemake -n
# Re-run a rule and its downstream: 
# snakemake --cores 48 --use-conda --forceall spliceai
# snakemake --forceall vep --cores 48 --use-conda
# Caveats: 
#   only for grch38 (fasta and spliceai setting)
#   Nonmenclature: {sample}_R1_001.fastq.gz, {sample}_R2_001.fastq.gz

configfile: "config/config.yaml"

# Get prefix of fastq files
from os import listdir
from sys import exit
sample_names = []
for name in listdir("fastq"):
    if "_R1_001.fastq.gz" in name:
        sample_names.append(name[:-16])
    elif "_R2_001.fastq.gz" in name:
        sample_names.append(name[:-16])
    else:
        exit("Please format fastq file name as " +\
        "{sample}_R1_001.fastq.gz & {sample}_R2_001.fastq.gz" +\
        "for read 1 and read 2 & respectively")
sample_names = list(set(sample_names))
print(sample_names)

rule all:
    input:
        "multiqc_report.html"

rule fastp:
    input:
        read1=expand("fastq/{sample}_R1_001.fastq.gz", sample = sample_names),
        read2=expand("fastq/{sample}_R2_001.fastq.gz", sample = sample_names)
    output:
        read1=temp("fastq/clean_{sample}_R1_001.fastq.gz"),
        read2=temp("fastq/clean_{sample}_R2_001.fastq.gz"),
        report="results/quality_control/{sample}.fastp.html",
        json="results/quality_control/{sample}.fastp.json"
    conda:
        "envs/fastp.yaml"
    threads:
        config["threads"]
    shell:
        "fastp -i {input.read1} -I {input.read2} "
        "-o {output.read1} -O {output.read2} -h {output.report} -j {output.json}"
        " --detect_adapter_for_pe --qualified_quality_phred 15 "
        "--unqualified_percent_limit 40 --length_required 15 --thread {threads}"

rule dragmap:
    input:
        read1="fastq/clean_{sample}_R1_001.fastq.gz",
        read2="fastq/clean_{sample}_R2_001.fastq.gz"
    output:
        temp("sam/{sample}.sam")
    conda:
        "envs/dragmap.yaml"
    shell:
        "dragen-os -r resources/reference "
        "-1 {input.read1} -2 {input.read2} "
        "--output-directory sam/ "
        "--output-file-prefix {wildcards.sample}"

rule markduplicates:
    input:
        "sam/{sample}.sam"
    output:
        "bam/{sample}.sorted.removed_duplicates.bam"
    conda:
        "envs/gatk.yaml"
    shell:
        "gatk MarkDuplicatesSpark -I {input} -O {output} "
        "--remove-all-duplicates"

rule calibratedrag:
    input:
        expand("bam/{sample}.sorted.removed_duplicates.bam", 
               sample = sample_names)
    params:
        genome="resources/genome/Homo_sapiens_assembly38_masked.fasta",
        str_table="resources/genome/Homo_sapiens_assembly38_masked.tsv"
    output:
        temp("{sample}.dragstr_model.txt")
    conda:
        "envs/gatk4.yaml"
    threads:
        config["threads"]
    shell:
        "gatk CalibrateDragstrModel -R {params.genome} -I {input} "
        "-str {params.str_table} --threads {threads} -O {output}"

rule haplotypecaller:
    input:
        bam="bam/{sample}.sorted.removed_duplicates.bam", 
        genome="resources/genome/Homo_sapiens_assembly38_masked.fasta",
        interval_list=config["intervals_list"],
        dragstr_params="{sample}.dragstr_model.txt"
    output:
        "vcf/raw/{sample}.raw.vcf"
    conda:
        "envs/gatk4.yaml"
    threads:
        config["threads"]
    shell:
        "gatk HaplotypeCaller -R {input.genome} -I {input.bam} -O {output} "
        "--dragen-mode true --dragstr-params-path {input.dragstr_params} "
        "--native-pair-hmm-threads {threads}"

rule hardfilter:
    input:
        "vcf/raw/{sample}.raw.vcf"
    output:
        "vcf/hardfiltered/{sample}.hardfiltered.vcf"
    conda:
        "envs/gatk4.yaml"
    shell:
        "gatk VariantFiltration -V {input} "
        "--filter-expression 'QUAL < 10.4139' "
        "--filter-name 'DRAGENHardQUAL' -O {output}"

rule vep:
    input:
        vcf="vcf/hardfiltered/{sample}.hardfiltered.vcf", 
        genome="resources/genome/Homo_sapiens_assembly38_masked.fasta"
    output:
        out_vcf="vcf/vep/{sample}.vep.vcf",
        report="results/vep_annotation/{sample}_variants_summary.html"
    conda:
        "envs/vep.yaml"
    shell:
        "vep -i {input.vcf} --output_file {output.out_vcf} "
        "--stats_file {output.report} --cache --vcf "
        "--dir_cache resources/vep_cache " 
        "--species 'homo_sapiens' --force_overwrite "
        "--af --max_af --af_1kg --af_gnomad "
        "--fasta {input.genome} --hgvs --hgvsg --offline --minimal "
        "--custom resources/vep_cache/ClinVar/"
        "clinvar.vcf.gz,ClinVar,vcf,exact,0,ClinVar,vcf,exact,0,AF_ESP,AF_EXAC,"
        "AF_TGP,ALLELEID,CLNDN,CLNDNINCL,CLNDISDB,CLNDISDBINCL,CLNHGVS,CLNREVSTAT,"
        "CLNSIG,CLNSIGCONF,CLNSIGINCL,CLNVC,CLNVCSO,CLNVI,DBVARID,GENEINFO,MC,"
        "ORIGIN,RS,SSR "
        "--custom resources/vep_cache/NARD/"
        "NARD_MAF.hg38.liftover.sorted.vcf.gz,NARD,vcf,exact,0,AF,AF_MNG,AF_KOR,"
        "AF_JPN,AF_CHN,AF_HKG"

rule spliceai:
    input:
        genome="resources/genome/Homo_sapiens_assembly38_masked.fasta",
        vcf="vcf/vep/{sample}.vep.vcf"
    output:
        "vcf/spliceai/{sample}.spliceai.vcf"
    conda:
        "envs/spliceai.yaml"
    shell:
        "spliceai -I {input.vcf} -O {output} -R {input.genome} -A grch38"

rule variantstotable:
    input:
        "vcf/spliceai/{sample}.spliceai.vcf"
    output:
        "vcf/tsv/{sample}.tsv"
    conda:
        "envs/gatk4.yaml"
    shell:
        "gatk VariantsToTable -V {input} -O {output} --show-filtered "
        "-F CHROM -F POS -F ID -F REF -F ALT "
        "-GF AD -GF DP -GF GP -GF GQ -GF GT -GF PG -GF PL -F AC -F AF -F AN "
        "-F BaseQRankSum -F DP -F DRAGstrInfo -F DRAGstrParams -F ExcessHet "
        "-F FS -F InbreedingCoeff -F MLEAC -F MLEAF -F MQ -F MQRankSum -F QD "
        "-F ReadPosRankSum -F SOR -F CSQ "

rule finis:
    input:
        tsv="vcf/tsv/{sample}.tsv"
    params:
        gnomadcsv=config["gnomad_v3.1.2_csv"],
        csq_heads=config["csq"],
        filters=config["filter_tags"]
    output:
        directory("results/called_variants/{sample}/")
    conda:
        "envs/finis.yaml"
    shell:
        "python3 resources/finis/finis/finis.py "
        "--vcf_tsv {input.tsv} --gnomadCSV {params.gnomadcsv} "
        "--csq_headers {params.csq_heads} --filter_tags {params.filters} "
        "--output {output}"

rule multiqc:
    input:
        expand("results/called_variants/{sample}/{sample}_gnomadAnnotated.csv", 
               sample = sample_names)
    output:
        "multiqc_report.html"
    conda:
        "envs/multiqc.yaml"
    shell:
        "multiqc --force --ignore resources ."

onsuccess:
    print("Workflow finished, no error")

onerror:
    print("An error occurred")
    shell("mail -s 'an error occurred' {config['email']} < {log}")